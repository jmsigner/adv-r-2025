---
title: "Build Your Own R Package"
format: html
editor: visual
---

# Introduction

Welcome! In this session, you'll learn how to create your own R package.

## Learning Goals

-   üõ†Ô∏è Setting Up the Package Structure
-   üíª Adding a Function and Documentation
-   üß© Testing Your Package with **testthat**
-   ‚òï Package Checking, Installation, and Usage
-   ‚ö° (Optional) Advanced Topics and Extensions
-   ‚ö° (Optional) Publishing Your Package on GitHub

------------------------------------------------------------------------

# üõ†Ô∏è Setting Up the Package Structure

## 1. Create a New R Package

``` r
# Load devtools and usethis
library(devtools)
library(usethis)

create_package("forestMetrics", check_name = FALSE) # adjust path and name to your liking

# RStudio will create a new project and open it for you
## Load devtools and usethis for the new R session
library(devtools)
library(usethis)

use_package("terra")            # add dependencies
use_git()                       # initialize git repository, needs to restart the R session. Don't forget to load `devtools` and `usethis` again after the restart.
```

Note 1: `devtools` can be a bit tricky to install. Ubuntu users may need to install `libcurl4-openssl-dev libssl-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev libxml2-dev libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev` before installing `devtools` in R. Windows users may need to install [Rtools](https://cran.r-project.org/bin/windows/Rtools/). If nothing works, you can use rstudio.gwdg.de or https://jupyter.hpc.gwdg.de (docs [here](https://docs.hpc.gwdg.de/services/rstudio/index.html)).

Note 2: `terra` might also be tricky to install, especially on Linux. If you run into issues, have a look at their [installation instructions](https://github.com/rspatial/terra?tab=readme-ov-file#installation).

## 2. Set Up Package Metadata

Open the `DESCRIPTION` file and update:

-   Title
-   Description
-   Authors
-   License (optional, use `use_mit_license()`, for example)

``` r
# Example
use_mit_license("Your Name")
use_package("terra") # see `?use_package` on how to add a specific version of a package
```

Have a look at the `NAMESPACE` file: it controls function exports and imports. We won‚Äôt edit this by hand ‚Äì it will be generated by another tool - `roxygen2`.

Other common components of your package: man/ (manual documentation files generated from `roxygen2`), tests/ (for test scripts), vignettes/ (for longer-form documentation or tutorials), etc. We will touch on some of these later.

You could edit all files by hand, but it is way easier to use packages like `usethis` or `roxygen2` to automate this process.

## 3. Add a Function

``` r
# Create new R script for the function
use_r("calc_area")

# Add function
total_area <- function(landscape) {
  stopifnot(inherits(landscape, "SpatRaster"))
  # calculate patch areas (simplified)
  area_ha <- terra::cellSize(landscape, mask = TRUE, unit = "ha")
  total <- sum(terra::values(area_ha), na.rm = TRUE)

  return(total)
}
```

------------------------------------------------------------------------

# 4. Document the Function

Click on the function name (i.e. `total_area`) to move the cursor there. Then, Alt + Ctrl + Shift + R (or Cmd + Option + Shift + R on Mac) to generate the documentation template. Alternatively, you can use use the menu `Code -> Insert Roxygen Skeleton` or write the documentation manually using `roxygen2` syntax.

``` r
#' Compute total area of a landscape
#'
#' @param landscape SpatRaster, the landscape raster (terra SpatRaster object)
#'
#' @return Total area in hectares (ha), omitting NA values.
#' @examples
#' library(terra)
#' landscape <- terra::rast(matrix(1, 10, 10)) # example raster
#' total_area(landscape)
#' @export
```

``` r
# Generate documentation
devtools::document()
```

This will create a `man/` directory with documentation files for your functions. The `@export` tag makes the function available to users of your package. Have a look at the `man/` directory to see how the documentation is structured. Also your NAMESPACE file will be updated to include the new function.

You can also use the menu `Build -> More -> Document` in RStudio or configure your build tools to automatically run `devtools::document()` when you build your package: `Build -> Configure Build Tools...` and check the box for "Document on build".

## 5. Load and Test

``` r
# Load package
devtools::load_all() # or use the Install button in RStudio (build tab in the top right corner)

# Try out the function
?total_area

load(landscape.rda) # load example data from GitHub
total_area(landscape)
```

## 6. Add a Unit Test

``` r
library(testthat)
library(usethis)

use_testthat() # Initialize testthat framework, creates a tests/testthat/ directory - run once, only.
use_test("total_area") # Create a test test-total_area.R file for the total_area function

# Inside test-total_area.R
test_that("Total area calculation", {
  # Load example data
  landscape <- terra::rast(matrix(1, 10, 10)) # you might want to test a more realistic landscape raster
  
  # Test the function
  result <- total_area(landscape)
  
  # Check if the result is a numeric value (this is the first unit test)
  expect_type(result, "double")
  
  # Check if the result is greater than zero (assuming landscape has some area)
  # This is a second unit test
  expect_true(result > 0)
})
```

This code creates the test infrastructure using usethis: `usethis::use_testthat()`. This will set up the tests/ folder and add testthat to the Suggests in DESCRIPTION (since tests are typically not needed by the user of the package, just for development). It also creates a template file tests/testthat.R which is needed to run the tests. The actual tests are written in `tests/testthat/test-your_function_name.R`.

Now you can run the tests using:

``` r
devtools::test()
```

Try to deliberately break the test by changing the `expect_true(result > 0)` to `expect_true(result < 0)` and run `devtools::test()` again. You should see that the test fails, which is expected.

Testing is an important part of package development, especially when you plan to collaborate and share your package with others. It helps you catch bugs early and ensures that your functions behave as expected. You can write multiple tests for different aspects of your function, and you can also use `testthat` to test for specific conditions, such as errors or warnings.

## 7. More checks, building and installation

You can check your package for common issues with `devtools::check()`. This will run a series of checks on your package, including checking the documentation, tests, and code style. It will also check if your package can be installed and loaded correctly. If you plan to submit your package to CRAN, `devtools::check()` needs to pass without any errors or warnings.

``` r
devtools::check() # takes a while...
```

# (Optional) Advanced Topics and Extensions

## Add data to your package

You can add data to your package by creating a `data/` directory and placing your data files there. You can use the `use_data()` function from `usethis` to create a data file from an R object:

``` r
use_data(landscape, overwrite = TRUE) # saves the landscape object to data/landscape.rda
```

## Add a vignette

You can add a vignette to your package to provide a longer-form documentation or tutorial. Vignettes are typically used to explain how to use your package or to provide examples of its functionality. You can create a vignette using the `use_vignette()` function from `usethis`:

``` r
use_vignette("forestMetrics") # creates a vignettes/ directory with a template vignette
```

## Add a README file

You can add a README file to your package to provide an overview of your package, its functionality, and how to use it. The README file is typically written in Markdown format and is displayed on the package's GitHub page or CRAN page. You can create a README file using the `use_readme_rmd()` function from `usethis`:

``` r
use_readme_rmd() # creates a README.Rmd file
```

## Use C++ for performance

If you need to optimize performance-critical code, you can use the `Rcpp` package to integrate C++ code into your R package. This is especially useful for computationally intensive tasks. You can create a C++ function using `Rcpp::cppFunction()` or by creating a separate C++ source file in the `src/` directory of your package.

You need a little bit of setup to use C++ in your R package. First, make sure you have the `Rcpp` package installed. Then you'll need a file R/yourPackageName-package.R (the name is not important, its just for setup). I'll use `forestMetrics-package.R`. Then you can use the `usethis` package to set up Rcpp in your package. This will create a `src/` directory where you can place your C++ code files:

``` r
library(usethis)
use_rcpp() # sets up Rcpp in your package and creates a src/ directory
```

When you look in the Console, you should see a message that you'll need to add some lines to your forestMetrics-package.R file. Just copy the lines and paste them into the file. This is necessary to link the compiled C++ code to your package. My file looks like this:

``` r
## usethis namespace: start
#' @importFrom Rcpp sourceCpp
## usethis namespace: end
NULL

## usethis namespace: start
#' @useDynLib forestMetrics, .registration = TRUE
## usethis namespace: end
NULL
```

Now, you can integrate C++ code into your R package using `usethis::use_rcpp()`:

``` r
use_rcpp(name = "rcpp_add.cpp") # sets up Rcpp in your package and creates a src/ directory with the C++ file

# Example C++ function src/rcpp_add.cpp
#include <Rcpp.h>
using namespace Rcpp;

//' @export
// [[Rcpp::export]]
double rcpp_add(double x, double y) {
  return x + y;
}
```

When you have added C++ code, you need to run `devtools::document()` again to update the NAMESPACE file and documentation. Then you can load your package and use the C++ function like any other R function:

``` r
library(forestMetrics)
rcpp_add(2, 3) # should return 5
```

# (Optional) Upload to GitHub

The easiest way to share your package with others is to upload it to GitHub. You can use the `usethis` package to set up a GitHub repository for your package.

``` r
library(usethis)
use_git() # Initialize a git repository if not already done
use_github() # This will prompt you to create a new GitHub repository
```

Now others can install your package using `devtools::install_github("yourusername/forestMetrics")`. Alternatively, you can also share the package as a `.tar.gz` file or a `.zip` file, which can be installed using `devtools::install_local("path/to/package.tar.gz")`. This file can be created using `devtools::build()`, which will create a `.tar.gz` or `.zip` file in the root directory of your package.

You can use GitHub also to automate your unit tests and checks using GitHub Actions. This way, every time you push changes to your repository, the tests will run automatically, and you can see if everything is working as expected. You can find more information about GitHub Actions in the [GitHub Actions documentation](https://docs.github.com/en/actions) and in the [usethis package documentation](https://usethis.r-lib.org/reference/use_github_action.html).

# Further Reading

-   <https://r-pkgs.org>
-   <https://style.tidyverse.org>
-   <https://testthat.r-lib.org>
-   <https://usethis.r-lib.org>

If you have any questions, please feel free to drop me an e-mail: shanss@uni-goettingen.de
